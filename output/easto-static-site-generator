<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="language" content="en">
    <title>Easto: a static-site generator</title>
    <meta name="description" content="null">
    <meta name="date" content="2018-03-06">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/styles.css"/>
    <link href="/" rel="home start" />

    <link href="/feed/atom" type="application/atom+xml" rel="alternate" title="Atom Feed" />
    <link href="/feed/json" type="application/json" rel="alternate" title="JSON Feed" />
    <link href="/feed/rss" type="application/rss+xml" rel="alternate" title="RSS Feed" />

    <meta property="og:title" content="Easto: a static-site generator" />
    <meta property="og:url" content="https://blog.thomaspuppe.de/easto-static-site-generator" />
    <meta property="og:type" content="article" />
    <meta property="og:article:published_time" content="2018-03-06" />
    <meta property="og:article:author" content="Thomas Puppe" />

</head>
<body>
    <header>
        <p><a href="https://blog.thomaspuppe.de/" rel="home start">Blog von Thomas Puppe, Web Developer.</a></p>
    </header>
    <article class="post">

        <div class="post__meta">
            <span class="post__category">#Webentwicklung</span>
            <time datetime="2018-03-06">06. March 2018</time>
        </div>

        <h1 class="post__title">Easto: a static-site generator</h1>

        <p>Dieses Blog wird √ºber einen <a href="">Static Site Generator</a> erzeugt. Zuletzt war die Open Source Software <a href="">Acrylamid</a> im Einsatz, die leider nicht mehr maintained wird.</p>
<p>Als Acrylamid Probleme hatte und ich</p>
<p>(Rant unterbringen: Was soll eigentlich dieser JAM Schei√ü? Ich klebe irgendwelche SAAS oder FAAS zusammen mit fremdem Datenspeicher, Generator-Software und Hosting, um meine 20 HTML Seiten zu hosten -- sind die verr√ºckt geworden? Und alle machen mit!</p>
<p>Der n√§chste Trend wird garantiert &quot;increase your JAM Stack with a self-hosted database&quot;.)</p>
<p><a href="">Alternative Generatoren</a> gibt es wie Sand am Meer. Eigentlich fand ich Gatsby ganz interessant, weil viel Integration in Richtung Contentful, Netlify, Algolia und co. Aber: das benutzt JS/React nicht nur zum Bauen der Seite, sondern m√ºllt das auch alles in das Ergebnis. Und schon habe ich f√ºr ein &quot;Hello World&quot; vier JS-Requests mit 250 KB Download.</p>
<p>Ich will nicht den JS-ist-b√∂se Meckerkopf spielen. Und f√ºr viele Anwendungen ist es eine gute Idee, einmal das Paket zu laden und dann bei jedem Klick Bytes zu sparen die nicht mehr durch die Leitung m√ºssen. Aber f√ºr eine Static Site oder ein Blog mit zwei oder drei Page Views pro Besuch ist das halt keine gute Idee. Und bei Gatsby wird es wohl wieder schwierig, das JS zu rauszufrickeln.</p>
<h2 id="easto-ein-static-site-generator-im-eigenbau">Easto: ein Static Site Generator im Eigenbau</h2>
<p>Langes Meckern, kurzer Sinn: ich hatte mich entschieden, einen eigenen Generator zu schreiben. Den entscheidenden Impuls gab mir <a href="TODO">TODO</a> bei einem <a href="TODO">Static Site Meetup in Berlin</a>, bei dem er daf√ºr warb, es einmal selbst zu probieren.</p>
<p>Erste Gehversuche hatte ich vor <stroke>Monaten</stroke> Jahren mit Ruby gemacht (<a href="GitHub/thomaspuppe/easto-ruby">https://github.com/thomaspuppe/easto-ruby</a>). Da ich mich 2018 aber entschieden hatte, mich auf JavaScript zu konzentrieren, startete ich einen zweiten Anlauf.</p>
<h2 id="schritt-1-markdown-dateien-iterieren-transformieren-und-speichern">Schritt 1: Markdown-Dateien iterieren, transformieren, und speichern</h2>
<p>Das Grundprinzip eines Static Site Generators l√§sst sich in wenigen Zeilen Code umsetzen. Lies Dateien (z.B. Blogposts) aus, mach etwas mit ihnen, und speichere das Ergebnis.</p>
<pre>const fs = require('fs')
fs.readdirSync('content')
  .forEach(sourceFilename => {
    const sourcePath = `content/${sourceFilename}`
    const content = fs.readFileSync(sourcePath, {encoding: 'utf-8'})
    // TODO: Verarbeiten
    const targetFilename = sourceFilename.replace('.md', '.html')
    const targetPath = `output/` + targetFilename
    fs.writeFileSync(targetPath, content)
  })</pre>

<p>In diesem Fall h√§tten wir alle Dateien aus einem Quellordner ausgelesen, und unter neuem Namen in einen Zielordner gespeichert. Das k√∂nnte man auch kopieren, ohne auszulesen, aber wir wollen ja noch etwas damit anfangen:</p>
<pre>const fs = require('fs')
const marked = require('marked')

fs.readdirSync('content')
  .forEach(sourceFilename => {
    const sourcePath = `content/${sourceFilename}`

    const contentMarkdown = fs.readFileSync(sourcePath, {encoding: 'utf-8'})
    const contentHtml = marked(contentMarkdown)

    const targetFilename = sourceFilename.replace('.md', '.html')
    const targetPath = `output/${targetFilename}`

    fs.writeFileSync(targetPath, contentHtml)
  })</pre>

<p>Im Befehl <code>const contentHtml = marked(contentMarkdown)</code> steckt die Magie. Texte, die in Markdown verfasst wurden, werden in HTML umgewandelt. Nat√ºrlich k√∂nnte man auch gleich in HTML schreiben. Oder beides! Mit dem npm Modul marked kann man sowohl schlankes Markdown schreiben, als auch im selben Text HTML verwenden, wenn Markdown nicht mehr ausreicht. Die <a href="TODO">Quelldatei dieses Blog-Posts</a> veranschaulicht das.</p>
<p>Aber zur√ºck zum Generator. Obiges Textbeispiel als JavaScript-Datei reicht (fast) schon aus, um ein kleines simples Blog zu erzeugen.</p>
<pre>$ node index.js
üöÄ Easto: 170.456ms</pre>

<p>Wie in der modernen JavaScript-Welt √ºblich, muss man vorher noch das &quot;marked&quot; Modul als Dependency mit dem aktuell coolen Paketmanager installieren.</p>
<p>Die Laufzeit des Scripts messe ich √ºbrigens mit</p>
<pre>console.time('üöÄ Easto')
...
console.timeEnd('üöÄ Easto')
</pre>

<p>am Anfang und Ende des Scripts.</p>
<h2 id="2-templating">2: Templating</h2>
<p>Nun ist der Output von Inhalt im HTML Format noch keine anst√§ndige Website. Alles um den eigentlichen Inhalt herum (Header, Navigation, Footer) m√∂chte ich ja auch nicht auf jeder einzelnen Seite pflegen. Also: Templating to the rescue!</p>
<p>Aber bevor ich irgendwelche Template-Engines lade, benutze ich simple String-Ersetzung. Das soll ja schlie√ülich ein einfacher Seiten-Editor werden, und kein Dependency-Monster.</p>
<p>Als erstes Template f√ºr mein Blog dient eine HTMl-Datei, deren Inhalt nur aus einem Platzhalter besteht.</p>
<pre>&lt;!doctype html&gt;
&lt;html lang="de"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Mein Blog&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Willkommen auf Thomas Puppes Blog!&lt;/h1&gt;
        {{ CONTENT }}
    &lt;/body&gt;
&lt;/html&gt;</pre>

<p>In meinem Generator lese ich nun zus√§tzlich das Template aus (au√üerhalb der Schleife, denn das bleibt ja gleich) und benutze es zum Zusammenbauen jeder einzelnen Seite.</p>
<pre>// Module laden

const template = fs.readFileSync('template.html', {encoding: 'utf-8'})

fs.readdirSync('content')
  .forEach(sourceFilename => {
    const sourcePath = `content/${sourceFilename}`

    const contentMarkdown = fs.readFileSync(sourcePath, {encoding: 'utf-8'})
    const contentHtml = marked(contentMarkdown)

    let contentPage = template.replace('{{ CONTENT }}', contentHtml)

    const targetFilename = sourceFilename.replace('.md', '.html')
    const targetPath = `output/` + targetFilename

    fs.writeFileSync(targetPath, contentPage)
  })</pre>

<p>Und schon enthalten die generierten Dateien das HTML des Templates und alle Inhalte.</p>
<p>Was sofort auff√§llt: der <code>title</code> ist gar nicht individuell. Den m√∂chte man aber gern setzen. Woraus eine zweite Frage folgt: woher bekomme ich den Titel √ºberhaupt?</p>
<h2 id="3-metadaten-yamlfrontmatter">3: Metadaten (YAML/Frontmatter)</h2>
<p>&quot;Frontmatter&quot; ist ein g√§ngiges Format, um in Dateien mit Inhalten au√üerdem noch Meta-Informationen zu schreiben. (TODO: Frontmatter Quelle verlinken, und das sauber erkl√§ren.) Das Format sieht aus wie folgt:</p>
<pre>---
title: Perfekte Link-Unterstreichung
language: de
permalink: link-unterstreichung
---
Hier beginnt der Inhalt. Er ist beliebig lang...</pre>

<p>In einen Block am Anfang der Datei werden die Meta-Informationen geschrieben. Nach einem Trenner (<code>---</code>) kommt dann der Inhalt. Weil diese Struktur sch√∂n einfach und definiert ist, kommen selbst Computer damit klar &mdash; und deswegen gibt es auch ein npm Modul daf√ºr: <a href="TODO">frontmatter</a>.</p>
<p>Im Detail unterscheiden sich die Module (zum Beispiel brauchen manche den Trenner auch am Anfang der Datei), und es gibt kleine Fallstricke (wenn der Titel einen Doppelpunkt enth√§lt, muss er in Anf√ºhrungsstriche gesetzt werden, damit klar wird was Struktur und was Inhalt ist). Aber im Grunde parst das Modul die Datei, und gibt die Werte strukturiert zur√ºck.</p>
<p>Ich setze weitere Platzhalter in das Template, und ersetze diese beim Zusammenbauen der HTML-Seiten.</p>
<p>Das Template sieht nun so aus:</p>
<pre>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Easto: a static-site generator&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Easto: a static-site generator&lt;/h1&gt;
        {{ CONTENT }}
    &lt;/body&gt;
&lt;/html&gt;</pre>

<p>und im JavaScript f√ºge ich hinter das Transformieren von Markdown in HTML die Schleife zur Ersetzung aller Metadaten ein.</p>
<pre>const content = fs.readFileSync(sourcePath, {encoding: 'utf-8'})

// parse die Datei mit Inhalt und Metadaten
const frontmatter = yaml.loadFront(content)

// der Teil unter dem Trenner steht als "__content" zur Verf√ºgung
let contentHtml = marked(frontmatter.__content)
let contentPage = template.replace('{{ CONTENT }}', contentHtml)

// die Yaml-Teile √ºber dem Trenner sind nun Felder im "frontmatter" Objekt
contentPage = contentPage.replace('{{ META_title }}', frontmatter['title'])
contentPage = contentPage.replace('{{ META_language }}', frontmatter['language'])</pre>

<p>Das yaml-Modul habe ich am Anfang des Scripts via <code>const yaml = require(&#39;yaml-front-matter&#39;)</code> geladen, und vorher mit dem Paketmanager installiert.</p>
<p>Die Werte aus dem Frontmatter kann man nat√ºrlich nicht nur f√ºr den Inhalt der Seiten benutzen, sondern auch f√ºr den Dateinamen.</p>
<pre>const targetFilename = frontmatter['permalink'] + '.md`</pre>

<p>Wenn man die Struktur h√§ufiger erweitert, oder es etwas bequemer haben m√∂chte, kann man nat√ºrlich auch √ºber alle Metadaten iterieren und diese im Template generisch ersetzen. Das ist dann schon etwas fortgeschrittener:</p>
<pre>for (var key in contentFrontmatter) {
    const re = new RegExp('{{ META_' + key.toUpperCase() + ' }}', 'g')

    // Frontmatter unterst√ºtzt auch Arrays im Format
    // "tags: [Webentwicklung, Magic, Internet]"
    if ( key === 'tags') {
        const tagsString = contentFrontmatter[key].join(', #')
        contentPage = contentPage.replace(re, tagsString)
    } else {
        contentPage = contentPage.replace(re, contentFrontmatter[key])
    }
}</pre>

<p>Bei der Entwicklung von diesen Algorithmen kann man wunderbar in kleinen Schritten vorgehen, weil man binnen Milliskunden das Ergebnis seiner Bemhung im Browser betrachten kann. Hoch lebe die handgestrickte Webentwicklung!</p>
<h2 id="4-inhaltsverzeichnis">4: Inhaltsverzeichnis</h2>
<p>Mit dem bisherigen Code wurden also allerlei Inhalts-Seiten oder Blog-Artikel generiert. Eine dieser Seiten k√∂nnte die Startseite sein, die man nat√ºrlich h√§ndisch anlegen und pflegen kann. Ich m√∂chte aber, dass die Startseite meines Blog austomatisch eine Liste aller Blogposts enth√§lt und darauf verlinkt. Auch das habe ich easto beigebracht.</p>
<p>Beim Iterieren √ºber alle Inhalte baue ich nicht nur die jeweilige Seite zusammen, sondern jeweils auch einen Link zur Seite. Und die gesammelten Links werden am Ende als Index-Seite gespeichert.</p>
<pre>
let teaserList = [];

... .forEach(sourceFilename => {
...
    teaserList.push(`<li><a href="${frontmatter['permalink']}">${frontmatter['title']}</a></li>`)
}

const indexTemplate = fs.readFileSync('template_index.html', {encoding: 'utf-8'})

let indexContent = indexTemplate.replace(
  '{{ CONTENT_BODY }}',
  teaserList.join()
)

fs.writeFileSync('output/index.html', indexContent)</pre>

<p>Das l√§sst sich nun mit der bekannten Technik der Templates erweitern, damit aus der simplen Linkliste sch√∂ne Teaser-Bl√∂cke werden.</p>
<pre></pre>

<p>Beim Ansehen der index-Seite f√§llt auf, dass die Quelldatien in &quot;zuf√§lliger&quot; Reihenfolge von der Platte gelesen werden. Ich l√∂se das, indem ich als Pr√§fix f√ºr meine Dateinamen das Datum jedes Blogposts benutze, und zwischen Auslesen und Verarbeiten eine Sortierung setze:</p>
<pre>fs
  .readdirSync('content')
  .sort((a, b) => {
    return b.localeCompare(a)
  })
  .forEach(sourcFilename => { ...</pre>


<h2 id="5-statische-dateien-kopieren">5: Statische Dateien kopieren</h2>
<p>Assets, Bilder und andere statische Dateien kopiere ich einfach in den Output-Folder.</p>
<pre>const ncp = require('ncp').ncp
ncp('static', 'output', err => {
  if (err) return console.error(err)
})
</pre>


<h2 id="6-feeds-generieren">6: Feeds generieren</h2>
<h2 id="struktur-und-√ºbersicht">Struktur und √úbersicht</h2>


    </article>
</body>
</html>
